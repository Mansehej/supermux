#!/usr/bin/env bash
set -euo pipefail

TMUX_BIN="${TMX_TMUX_BIN:-tmux}"

FZF_QUERY="${TMX_QUERY:-${TMX_PROCESS_QUERY:-}}"
SCOPE_DIR="${TMX_SCOPE_DIR:-${PWD:-.}}"
SCOPE_MODE="${TMX_SCOPE_MODE:-pwd}" # pwd | git
ALL="${TMX_ALL:-0}"
TSV=0

have() { command -v "$1" >/dev/null 2>&1; }
die() { printf 'supermux: %s\n' "$*" >&2; exit 1; }

require_tmux() { have "$TMUX_BIN" || die "tmux not found"; }
require_fzf() { have fzf || die "fzf not found (macOS: brew install fzf)"; }

canonical_path() {
  local dir="$1"
  if [[ -d "$dir" ]]; then
    (cd "$dir" 2>/dev/null && pwd -P) || printf '%s' "$dir"
  else
    printf '%s' "$dir"
  fi
}

scope_root() {
  local dir
  dir="$(canonical_path "$SCOPE_DIR")"

  if [[ "$SCOPE_MODE" == "git" ]] && have git; then
    local git_root
    git_root="$(git -C "$dir" rev-parse --show-toplevel 2>/dev/null || true)"
    if [[ -n "$git_root" ]]; then
      canonical_path "$git_root"
      return 0
    fi
  fi

  printf '%s' "$dir"
}

sanitize_session_name() {
  local s="$1"
  s="$(printf '%s' "$s" | tr ' ' '-' | tr -cd '[:alnum:]_-')"
  s="$(printf '%s' "$s" | sed 's/--*/-/g; s/^-//; s/-$//')"
  [[ -n "$s" ]] || s="session"
  case "$s" in
    -*) s="s${s}" ;;
  esac
  printf '%s' "$s"
}

short_hash() {
  local input="$1"
  if have shasum; then
    printf '%s' "$input" | shasum -a 256 | awk '{print substr($1,1,8)}'
    return 0
  fi
  if have python3; then
    python3 -c 'import hashlib,sys; print(hashlib.sha256(sys.argv[1].encode()).hexdigest()[:8])' "$input"
    return 0
  fi
  printf '%s' "$input" | cksum | awk '{print $1}'
}

tmux_cmd() { "$TMUX_BIN" "$@"; }

set_session_meta() {
  local session="$1"
  local root="$2"
  local logical="$3"

  tmux_cmd set-option -t "$session" -q @tmx_root "$root"
  tmux_cmd set-option -t "$session" -q @tmx_name "$logical"
}

find_session_by_meta() {
  local root="$1"
  local logical="$2"

  local session r n
  while IFS=$'\t' read -r session r n; do
    [[ -n "${session:-}" ]] || continue
    [[ "${r:-}" == "$root" ]] || continue

    if [[ -n "${n:-}" ]]; then
      [[ "$n" == "$logical" ]] || continue
      printf '%s' "$session"
      return 0
    fi

    [[ "$session" == "$logical" ]] || continue
    printf '%s' "$session"
    return 0
  done < <(
    tmux_cmd list-sessions -F $'#{session_name}\t#{?@tmx_root,#{@tmx_root},-}\t#{?@tmx_name,#{@tmx_name},#{session_name}}' 2>/dev/null || true
  )

  return 1
}

choose_actual_session_name() {
  local root="$1"
  local logical="$2"

  local slug base h cand
  slug="$(sanitize_session_name "$logical")"
  base="$(sanitize_session_name "$(basename "$root")")"
  h="$(short_hash "$root")"

  for cand in "$slug" "${base}--${slug}" "${slug}--${h}" "${base}--${slug}--${h}"; do
    if ! tmux_cmd has-session -t "$cand" 2>/dev/null; then
      printf '%s' "$cand"
      return 0
    fi
  done

  local i=2
  while :; do
    cand="${slug}--${h}--${i}"
    if ! tmux_cmd has-session -t "$cand" 2>/dev/null; then
      printf '%s' "$cand"
      return 0
    fi
    i=$((i + 1))
  done
}

attach_or_switch() {
  local session="$1"
  [[ -n "$session" ]] || return 0

  if [[ -n "${TMUX:-}" ]]; then
    tmux_cmd switch-client -t "$session"
  else
    tmux_cmd attach-session -t "$session"
  fi
}

default_logical_name() {
  local root="$1"
  local n
  n="$(basename "$root")"
  [[ -n "$n" && "$n" != "/" && "$n" != "." ]] || n="main"
  printf '%s' "$n"
}

new_session() {
  local logical="${1:-}"
  local root="$SCOPE_ROOT"

  [[ -n "$logical" ]] || logical="$(default_logical_name "$root")"

  local existing
  existing="$(find_session_by_meta "$root" "$logical" || true)"
  if [[ -n "$existing" ]]; then
    attach_or_switch "$existing"
    return 0
  fi

  local actual
  actual="$(choose_actual_session_name "$root" "$logical")"

  tmux_cmd new-session -d -s "$actual" -c "$root"
  set_session_meta "$actual" "$root" "$logical"
  attach_or_switch "$actual"
}

list_lines() {
  local filter_root="$SCOPE_ROOT"

  (tmux_cmd list-sessions -F $'#{session_name}\t#{session_windows}\t#{session_attached}\t#{?session_activity_string,#{session_activity_string},-}\t#{?@tmx_root,#{@tmx_root},-}\t#{?@tmx_name,#{@tmx_name},#{session_name}}' 2>/dev/null || true) \
  | while IFS=$'\t' read -r session wins attached activity root logical; do
      [[ -n "${session:-}" ]] || continue

      if [[ "$ALL" != "1" ]]; then
        [[ -n "${root:-}" && "$root" == "$filter_root" ]] || continue
      fi

      local display="$logical"
      [[ -n "${display:-}" ]] || display="$session"

      local att="-"
      [[ "${attached:-0}" != "0" ]] && att="att"

      local procs
      procs="$(
        (tmux_cmd list-panes -t "$session" -s -F '#{pane_current_command}' 2>/dev/null || true) \
          | sort \
          | uniq -c \
          | awk '{printf "%s%s(%s)", (NR>1?",":""), $2, $1} END{if(NR==0) printf "-"}'
      )"

      local root_out="${root:-}"
      [[ -n "$root_out" ]] || root_out="-"

      printf '%s\t%s\t%s\t%s\t%s\t%s\t%s\n' "$display" "$session" "$root_out" "${wins:-}" "$att" "${activity:-}" "${procs:-}"
    done
}

preview_one() {
  local session="${1:-}"
  [[ -n "$session" ]] || exit 0

  tmux_cmd display-message -p -t "$session" \
    'session=#{session_name}  name=#{@tmx_name}  dir=#{@tmx_root}  windows=#{session_windows}  attached=#{?session_attached,yes,no}  created=#{session_created_string}  activity=#{session_activity_string}' \
    2>/dev/null || true

  printf '\n'
  tmux_cmd list-windows -t "$session" -F '#{window_index}: #{window_name} (#{window_panes} panes)#{?window_active, [active],}' 2>/dev/null || true

  printf '\n'
  tmux_cmd list-panes -t "$session" -s -F '#{window_index}.#{pane_index}  #{pane_current_command}  pid=#{pane_pid}  #{pane_current_path}' 2>/dev/null || true
}

kill_sessions() {
  local session
  for session in "$@"; do
    [[ -n "$session" ]] || continue
    tmux_cmd kill-session -t "$session" 2>/dev/null || true
  done
}

detach_sessions() {
  local session
  for session in "$@"; do
    [[ -n "$session" ]] || continue
    tmux_cmd detach-client -s "$session" 2>/dev/null || true
  done
}

pick_interactive() {
  require_fzf

  local with_nth
  if [[ "$ALL" == "1" ]]; then
    with_nth='1,3,4,5,6,7'
  else
    with_nth='1,4,5,6,7'
  fi

  local self_q
  self_q="$(printf '%q' "$TMX_SELF")"

  local picked
  picked="$(
    list_lines \
    | fzf --delimiter=$'\t' --with-nth="$with_nth" \
      --prompt='supermux> ' \
      --query="${FZF_QUERY:-}" \
      --header=$'Enter: attach/switch   Ctrl-D: detach selected   Ctrl-X: kill selected   Ctrl-R: refresh' \
      --preview "$self_q __preview {2}" --preview-window=down,60%,wrap \
      --bind "ctrl-r:reload($self_q __list)" \
      --bind "ctrl-d:execute-silent($self_q __detach {+2})+reload($self_q __list)" \
      --bind "ctrl-x:execute-silent($self_q __kill {+2})+reload($self_q __list)"
  )" || exit 0

  local session
  session="$(printf '%s\n' "$picked" | awk -F$'\t' 'NR==1{print $2}')"
  [[ -n "$session" ]] || exit 0

  attach_or_switch "$session"
}

kill_interactive() {
  require_fzf

  local with_nth
  if [[ "$ALL" == "1" ]]; then
    with_nth='1,3,4,5,6,7'
  else
    with_nth='1,4,5,6,7'
  fi

  local self_q
  self_q="$(printf '%q' "$TMX_SELF")"

  local sel
  sel="$(
    list_lines \
    | fzf --multi --delimiter=$'\t' --with-nth="$with_nth" \
      --prompt='kill> ' \
      --query="${FZF_QUERY:-}" \
      --preview "$self_q __preview {2}" --preview-window=down,60%,wrap
  )" || exit 0

  local sessions
  sessions="$(printf '%s\n' "$sel" | awk -F$'\t' '{print $2}')"

  local count
  count="$(printf '%s\n' "$sessions" | sed '/^$/d' | wc -l | tr -d ' ')"
  [[ "$count" -gt 0 ]] || exit 0

  printf 'Kill %s session(s)? [y/N] ' "$count" > /dev/tty
  local ans
  read -r ans < /dev/tty || exit 0
  case "$ans" in
    y|Y|yes|YES) ;;
    *) exit 0 ;;
  esac

  local s
  while IFS= read -r s; do
    [[ -n "$s" ]] || continue
    tmux_cmd kill-session -t "$s" 2>/dev/null || true
  done <<<"$sessions"
}

usage() {
  cat <<'TMX_USAGE'
Usage:
  supermux new NAME            Create/switch to NAME scoped to current dir
  supermux list                List sessions scoped to current dir
  supermux detach [NAME]       Detach current client or detach NAME's clients
  supermux                     Interactive picker (requires fzf)
  supermux kill                Interactive kill (requires fzf)

Options:
  -a, --all               Use all sessions (list/picker/kill)
  -p, --process STR       Prefill picker query (alias: --query)
  -q, --query STR         Prefill picker query
  --tsv                   list: output raw TSV
  --scope DIR             Scope to this directory (default: $PWD)
  --scope-mode pwd|git    Scope root mode (default: pwd)
TMX_USAGE
}

cmd=""
cmd_args=()
end_opts=0

while [[ $# -gt 0 ]]; do
  if [[ "$end_opts" == "1" ]]; then
    if [[ -z "$cmd" ]]; then
      cmd="$1"
    else
      cmd_args+=("$1")
    fi
    shift
    continue
  fi

  case "$1" in
    --)
      end_opts=1
      shift
      ;;
    -a|--all)
      ALL=1
      shift
      ;;
    -p|--process|-q|--query)
      [[ $# -ge 2 ]] || die "missing value for $1"
      FZF_QUERY="$2"
      shift 2
      ;;
    --tsv)
      TSV=1
      shift
      ;;
    --scope)
      [[ $# -ge 2 ]] || die "missing value for $1"
      SCOPE_DIR="$2"
      shift 2
      ;;
    --scope-mode)
      [[ $# -ge 2 ]] || die "missing value for $1"
      SCOPE_MODE="$2"
      shift 2
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    -* )
      die "unknown option: $1"
      ;;
    *)
      if [[ -z "$cmd" ]]; then
        cmd="$1"
      else
        cmd_args+=("$1")
      fi
      shift
      ;;
  esac
done

[[ -n "$cmd" ]] || cmd="pick"
if [[ ${#cmd_args[@]} -gt 0 ]]; then
  set -- "${cmd_args[@]}"
else
  set --
fi

require_tmux
SCOPE_ROOT="$(scope_root)"

export TMX_SCOPE_DIR="$SCOPE_DIR"
export TMX_SCOPE_MODE="$SCOPE_MODE"
export TMX_QUERY="$FZF_QUERY"
export TMX_ALL="$ALL"

TMX_SELF="${BASH_SOURCE[0]}"
if [[ "$TMX_SELF" != /* ]]; then
  p="$(command -v "$TMX_SELF" 2>/dev/null || true)"
  [[ -n "$p" ]] && TMX_SELF="$p"
fi
export TMX_SELF

case "$cmd" in
  __list)
    list_lines
    ;;
  __preview)
    preview_one "${1:-}"
    ;;
  __detach)
    detach_sessions "$@"
    ;;
  __kill)
    kill_sessions "$@"
    ;;

  new)
    new_session "${1:-}"
    ;;

  detach)
    if [[ $# -eq 0 ]]; then
      if [[ -n "${TMUX:-}" ]]; then
        tmux_cmd detach-client
        exit 0
      fi

      if have fzf && [[ -t 0 ]] && [[ -t 1 ]]; then
        self_q="$(printf '%q' "$TMX_SELF")"

        sel="$(
          list_lines \
          | awk -F$'\t' '$5=="att" {print}' \
          | fzf --multi --delimiter=$'\t' --with-nth='1,4,5,6,7' \
              --prompt='detach> ' \
              --query="${FZF_QUERY:-}" \
              --preview "$self_q __preview {2}" --preview-window=down,60%,wrap
        )" || exit 0

        sessions="$(printf '%s\n' "$sel" | awk -F$'\t' '{print $2}')"
        while IFS= read -r s; do
          [[ -n "$s" ]] || continue
          detach_sessions "$s"
        done <<<"$sessions"
        exit 0
      fi

      die "not in tmux; use: supermux detach NAME"
    fi

    logical="$1"
    session="$(find_session_by_meta "$SCOPE_ROOT" "$logical" || true)"
    [[ -n "$session" ]] || die "no session '$logical' in scope ($SCOPE_ROOT)"

    tmux_cmd detach-client -s "$session" 2>/dev/null || true
    ;;

  list|ls)
    if [[ "$TSV" == "1" ]]; then
      list_lines
      exit 0
    fi

    if have column; then
      if [[ "$ALL" == "1" ]]; then
        { printf 'NAME\tSESSION\tDIR\tW\tATT\tACTIVITY\tPROCS\n'; list_lines; } | column -t -s $'\t'
      else
        { printf 'NAME\tSESSION\tW\tATT\tACTIVITY\tPROCS\n'; list_lines | awk -F$'\t' 'BEGIN{OFS="\t"} {print $1,$2,$4,$5,$6,$7}'; } | column -t -s $'\t'
      fi
    else
      if [[ "$ALL" == "1" ]]; then
        printf 'NAME\tSESSION\tDIR\tW\tATT\tACTIVITY\tPROCS\n'
        list_lines
      else
        printf 'NAME\tSESSION\tW\tATT\tACTIVITY\tPROCS\n'
        list_lines | awk -F$'\t' 'BEGIN{OFS="\t"} {print $1,$2,$4,$5,$6,$7}'
      fi
    fi
    ;;

  pick)
    pick_interactive
    ;;

  all)
    ALL=1
    export TMX_ALL=1
    pick_interactive
    ;;

  kill)
    kill_interactive
    ;;

  *)
    die "unknown command: $cmd"
    ;;
esac
